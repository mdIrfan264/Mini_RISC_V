# ðŸ“Œ Program Counter (PC) â€“ Detailed Documentation

## 1. Introduction

The **Program Counter (PC)** is a fundamental register in a CPU that holds the **address of the next instruction to be executed**.
In this Mini RISC-V processor, the PC is implemented as a **32-bit register** and updated on every clock cycle.

---

## 2. Role of PC in RISC-V Processor

The PC performs the following key functions:

* Holds the address of the **current instruction**
* Supplies the address to the **instruction memory**
* Determines the **next instruction address**
* Supports **sequential execution** and **control flow changes** (branches)

---

## 3. PC in Single-Cycle Architecture

This processor uses a **single-cycle architecture**, meaning:

* One instruction completes in **one clock cycle**
* PC updates **once per clock**
* No pipeline registers are used

### Execution Flow:

```
PC â†’ Instruction Memory â†’ Decode â†’ Execute â†’ PC Update
```

---

## 4. PC Update Logic

### Default Case (Sequential Execution)

```
PC_next = PC + 4
```

* RISC-V instructions are **32-bit (4 bytes)**
* PC increments by 4 to fetch the next instruction

---

### Branch Case (BEQ)

```
PC_next = PC + immediate   (if Branch == 1 AND Zero == 1)
```

* `immediate` is generated by the **Immediate Generator**
* Offset is **sign-extended** and **left-shifted by 1**
* Branch target = PC-relative addressing

---

### Final PC Selection Logic

```verilog
assign pc_next = (Branch && Zero) ? pc + imm : pc + 4;
```

---

## 5. PC Module Implementation

### Verilog Code

```verilog
module pc (
    input clk,
    input reset,
    input [31:0] pc_next,
    output reg [31:0] pc
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            pc <= 32'b0;
        else
            pc <= pc_next;
    end
endmodule
```

---

## 6. Signal Description

| Signal Name | Width | Direction | Description                 |
| ----------- | ----- | --------- | --------------------------- |
| `clk`       | 1     | Input     | System clock                |
| `reset`     | 1     | Input     | Resets PC to 0              |
| `pc_next`   | 32    | Input     | Next instruction address    |
| `pc`        | 32    | Output    | Current instruction address |

---

## 7. Reset Behavior

* PC is **asynchronously reset**
* On reset:

```
PC = 0x00000000
```

* Instruction execution starts from address `0`

---

## 8. Interaction with Instruction Memory

The PC directly feeds the instruction memory:

```verilog
assign instruction = mem[pc[31:2]];
```

* Lower 2 bits are ignored because:

  * Instructions are **word-aligned**
  * Address increments in multiples of 4

---

## 9. PC and Branching

* Branch decision comes from:

  * `Branch` â†’ Control Unit
  * `Zero` â†’ ALU (comparison result)

If both are true:

* PC jumps to branch target

Else:

* PC moves sequentially

---

## 10. Design Characteristics

| Feature      | Description  |
| ------------ | ------------ |
| Architecture | Single-cycle |
| PC Width     | 32-bit       |
| Update Type  | Clocked      |
| Branching    | PC-relative  |
| Reset        | Asynchronous |
| ISA          | RV32I        |

---

## 11. Why PC Is Important

* Controls program flow
* Enables conditional execution
* Links instruction fetch and execution
* Essential for loops, branches, and jumps

Without the PC, **instruction sequencing is impossible**.

---

## 12. Limitations of Current PC Design

* No support for:

  * `JAL`
  * `JALR`
  * Exceptions
  * Interrupts

These can be added by extending the **PC selection logic**.

---

## 13. Future Improvements

* Add jump support (`JAL`, `JALR`)
* Add pipeline registers
* Support interrupt vectors
* Support CSR redirection

---

## 14. Summary

> The Program Counter is the heart of instruction sequencing in the Mini RISC-V processor.
> It ensures correct instruction fetch, supports branching, and enables smooth program execution in a single-cycle design.

